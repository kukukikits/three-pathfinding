{"version":3,"file":"three-pathfinding.modern.js","sources":["../src/Utils.js","../src/BinaryHeap.js","../src/Channel.js","../src/Pathfinding.js","../src/Builder.js","../src/AStar.js","../src/PathfindingHelper.js"],"sourcesContent":["import { BufferAttribute, BufferGeometry } from 'three';\r\n\r\nclass Utils {\r\n\r\n  static roundNumber (value, decimals) {\r\n    const factor = Math.pow(10, decimals);\r\n    return Math.round(value * factor) / factor;\r\n  }\r\n\r\n  static sample (list) {\r\n    return list[Math.floor(Math.random() * list.length)];\r\n  }\r\n\r\n  static distanceToSquared (a, b) {\r\n\r\n    var dx = a.x - b.x;\r\n    var dy = a.y - b.y;\r\n    var dz = a.z - b.z;\r\n\r\n    return dx * dx + dy * dy + dz * dz;\r\n\r\n  }\r\n\r\n  //+ Jonas Raoni Soares Silva\r\n  //@ http://jsfromhell.com/math/is-point-in-poly [rev. #0]\r\n  static isPointInPoly (poly, pt) {\r\n    for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)\r\n      ((poly[i].z <= pt.z && pt.z < poly[j].z) || (poly[j].z <= pt.z && pt.z < poly[i].z)) && (pt.x < (poly[j].x - poly[i].x) * (pt.z - poly[i].z) / (poly[j].z - poly[i].z) + poly[i].x) && (c = !c);\r\n    return c;\r\n  }\r\n\r\n  static isVectorInPolygon (vector, polygon, vertices) {\r\n\r\n    // reference point will be the centroid of the polygon\r\n    // We need to rotate the vector as well as all the points which the polygon uses\r\n\r\n    var lowestPoint = 100000;\r\n    var highestPoint = -100000;\r\n\r\n    var polygonVertices = [];\r\n\r\n    polygon.vertexIds.forEach((vId) => {\r\n      lowestPoint = Math.min(vertices[vId].y, lowestPoint);\r\n      highestPoint = Math.max(vertices[vId].y, highestPoint);\r\n      polygonVertices.push(vertices[vId]);\r\n    });\r\n\r\n    if (vector.y < highestPoint + 0.5 && vector.y > lowestPoint - 0.5 &&\r\n      this.isPointInPoly(polygonVertices, vector)) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static triarea2 (a, b, c) {\r\n    var ax = b.x - a.x;\r\n    var az = b.z - a.z;\r\n    var bx = c.x - a.x;\r\n    var bz = c.z - a.z;\r\n    return bx * az - ax * bz;\r\n  }\r\n\r\n  static vequal (a, b) {\r\n    return this.distanceToSquared(a, b) < 0.00001;\r\n  }\r\n\r\n  /**\r\n   * Modified version of BufferGeometryUtils.mergeVertices, ignoring vertex\r\n   * attributes other than position.\r\n   *\r\n   * @param {THREE.BufferGeometry} geometry\r\n   * @param {number} tolerance\r\n   * @return {THREE.BufferGeometry>}\r\n   */\r\n  static mergeVertices (geometry, tolerance = 1e-4) {\r\n\r\n    tolerance = Math.max( tolerance, Number.EPSILON );\r\n\r\n    // Generate an index buffer if the geometry doesn't have one, or optimize it\r\n    // if it's already available.\r\n    var hashToIndex = {};\r\n    var indices = geometry.getIndex();\r\n    var positions = geometry.getAttribute( 'position' );\r\n    var vertexCount = indices ? indices.count : positions.count;\r\n\r\n    // Next value for triangle indices.\r\n    var nextIndex = 0;\r\n\r\n    var newIndices = [];\r\n    var newPositions = [];\r\n\r\n    // Convert the error tolerance to an amount of decimal places to truncate to.\r\n    var decimalShift = Math.log10( 1 / tolerance );\r\n    var shiftMultiplier = Math.pow( 10, decimalShift );\r\n\r\n    for ( var i = 0; i < vertexCount; i ++ ) {\r\n\r\n      var index = indices ? indices.getX( i ) : i;\r\n\r\n      // Generate a hash for the vertex attributes at the current index 'i'.\r\n      var hash = '';\r\n\r\n      // Double tilde truncates the decimal value.\r\n      hash += `${ ~ ~ ( positions.getX( index ) * shiftMultiplier ) },`;\r\n      hash += `${ ~ ~ ( positions.getY( index ) * shiftMultiplier ) },`;\r\n      hash += `${ ~ ~ ( positions.getZ( index ) * shiftMultiplier ) },`;\r\n\r\n      // Add another reference to the vertex if it's already\r\n      // used by another index.\r\n      if ( hash in hashToIndex ) {\r\n\r\n        newIndices.push( hashToIndex[ hash ] );\r\n\r\n      } else {\r\n\r\n        newPositions.push( positions.getX( index ) );\r\n        newPositions.push( positions.getY( index ) );\r\n        newPositions.push( positions.getZ( index ) );\r\n\r\n        hashToIndex[ hash ] = nextIndex;\r\n        newIndices.push( nextIndex );\r\n        nextIndex ++;\r\n\r\n      }\r\n\r\n    }\r\n\r\n    // Construct merged BufferGeometry.\r\n\r\n    const positionAttribute = new BufferAttribute(\r\n      new Float32Array( newPositions ),\r\n      positions.itemSize,\r\n      positions.normalized\r\n    );\r\n\r\n    const result = new BufferGeometry();\r\n    result.setAttribute( 'position', positionAttribute );\r\n    result.setIndex( newIndices );\r\n\r\n    return result;\r\n\r\n  }\r\n}\r\n\r\nexport { Utils };\r\n","// javascript-astar\r\n// http://github.com/bgrins/javascript-astar\r\n// Freely distributable under the MIT License.\r\n// Implements the astar search algorithm in javascript using a binary heap.\r\n\r\nclass BinaryHeap {\r\n  constructor (scoreFunction) {\r\n    this.content = [];\r\n    this.scoreFunction = scoreFunction;\r\n  }\r\n\r\n  push (element) {\r\n    // Add the new element to the end of the array.\r\n    this.content.push(element);\r\n\r\n    // Allow it to sink down.\r\n    this.sinkDown(this.content.length - 1);\r\n  }\r\n\r\n  pop () {\r\n    // Store the first element so we can return it later.\r\n    const result = this.content[0];\r\n    // Get the element at the end of the array.\r\n    const end = this.content.pop();\r\n    // If there are any elements left, put the end element at the\r\n    // start, and let it bubble up.\r\n    if (this.content.length > 0) {\r\n      this.content[0] = end;\r\n      this.bubbleUp(0);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  remove (node) {\r\n    const i = this.content.indexOf(node);\r\n\r\n    // When it is found, the process seen in 'pop' is repeated\r\n    // to fill up the hole.\r\n    const end = this.content.pop();\r\n\r\n    if (i !== this.content.length - 1) {\r\n      this.content[i] = end;\r\n\r\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\r\n        this.sinkDown(i);\r\n      } else {\r\n        this.bubbleUp(i);\r\n      }\r\n    }\r\n  }\r\n\r\n  size () {\r\n    return this.content.length;\r\n  }\r\n\r\n  rescoreElement (node) {\r\n    this.sinkDown(this.content.indexOf(node));\r\n  }\r\n\r\n  sinkDown (n) {\r\n    // Fetch the element that has to be sunk.\r\n    const element = this.content[n];\r\n\r\n    // When at 0, an element can not sink any further.\r\n    while (n > 0) {\r\n      // Compute the parent element's index, and fetch it.\r\n      const parentN = ((n + 1) >> 1) - 1;\r\n      const parent = this.content[parentN];\r\n\r\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n        // Swap the elements if the parent is greater.\r\n        this.content[parentN] = element;\r\n        this.content[n] = parent;\r\n        // Update 'n' to continue at the new position.\r\n        n = parentN;\r\n      } else {\r\n        // Found a parent that is less, no need to sink any further.\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  bubbleUp (n) {\r\n    // Look up the target element and its score.\r\n    const length = this.content.length,\r\n      element = this.content[n],\r\n      elemScore = this.scoreFunction(element);\r\n\r\n    while (true) {\r\n      // Compute the indices of the child elements.\r\n      const child2N = (n + 1) << 1,\r\n        child1N = child2N - 1;\r\n      // This is used to store the new position of the element,\r\n      // if any.\r\n      let swap = null;\r\n      let child1Score;\r\n      // If the first child exists (is inside the array)...\r\n      if (child1N < length) {\r\n        // Look it up and compute its score.\r\n        const child1 = this.content[child1N];\r\n        child1Score = this.scoreFunction(child1);\r\n\r\n        // If the score is less than our element's, we need to swap.\r\n        if (child1Score < elemScore) {\r\n          swap = child1N;\r\n        }\r\n      }\r\n\r\n      // Do the same checks for the other child.\r\n      if (child2N < length) {\r\n        const child2 = this.content[child2N],\r\n          child2Score = this.scoreFunction(child2);\r\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\r\n          swap = child2N;\r\n        }\r\n      }\r\n\r\n      // If the element needs to be moved, swap it, and continue.\r\n      if (swap !== null) {\r\n        this.content[n] = this.content[swap];\r\n        this.content[swap] = element;\r\n        n = swap;\r\n      }\r\n\r\n      // Otherwise, we are done.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport { BinaryHeap };\r\n","import { Utils } from './Utils';\r\n\r\nclass Channel {\r\n  constructor () {\r\n    this.portals = [];\r\n  }\r\n\r\n  push (p1, p2) {\r\n    if (p2 === undefined) p2 = p1;\r\n    this.portals.push({\r\n      left: p1,\r\n      right: p2\r\n    });\r\n  }\r\n\r\n  stringPull () {\r\n    const portals = this.portals;\r\n    const pts = [];\r\n    // Init scan state\r\n    let portalApex, portalLeft, portalRight;\r\n    let apexIndex = 0,\r\n      leftIndex = 0,\r\n      rightIndex = 0;\r\n\r\n    portalApex = portals[0].left;\r\n    portalLeft = portals[0].left;\r\n    portalRight = portals[0].right;\r\n\r\n    // Add start point.\r\n    pts.push(portalApex);\r\n\r\n    for (let i = 1; i < portals.length; i++) {\r\n      const left = portals[i].left;\r\n      const right = portals[i].right;\r\n\r\n      // Update right vertex.\r\n      if (Utils.triarea2(portalApex, portalRight, right) <= 0.0) {\r\n        if (Utils.vequal(portalApex, portalRight) || Utils.triarea2(portalApex, portalLeft, right) > 0.0) {\r\n          // Tighten the funnel.\r\n          portalRight = right;\r\n          rightIndex = i;\r\n        } else {\r\n          // Right over left, insert left to path and restart scan from portal left point.\r\n          pts.push(portalLeft);\r\n          // Make current left the new apex.\r\n          portalApex = portalLeft;\r\n          apexIndex = leftIndex;\r\n          // Reset portal\r\n          portalLeft = portalApex;\r\n          portalRight = portalApex;\r\n          leftIndex = apexIndex;\r\n          rightIndex = apexIndex;\r\n          // Restart scan\r\n          i = apexIndex;\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // Update left vertex.\r\n      if (Utils.triarea2(portalApex, portalLeft, left) >= 0.0) {\r\n        if (Utils.vequal(portalApex, portalLeft) || Utils.triarea2(portalApex, portalRight, left) < 0.0) {\r\n          // Tighten the funnel.\r\n          portalLeft = left;\r\n          leftIndex = i;\r\n        } else {\r\n          // Left over right, insert right to path and restart scan from portal right point.\r\n          pts.push(portalRight);\r\n          // Make current right the new apex.\r\n          portalApex = portalRight;\r\n          apexIndex = rightIndex;\r\n          // Reset portal\r\n          portalLeft = portalApex;\r\n          portalRight = portalApex;\r\n          leftIndex = apexIndex;\r\n          rightIndex = apexIndex;\r\n          // Restart scan\r\n          i = apexIndex;\r\n          continue;\r\n        }\r\n      }\r\n    }\r\n\r\n    if ((pts.length === 0) || (!Utils.vequal(pts[pts.length - 1], portals[portals.length - 1].left))) {\r\n      // Append last point to path.\r\n      pts.push(portals[portals.length - 1].left);\r\n    }\r\n\r\n    this.path = pts;\r\n    return pts;\r\n  }\r\n}\r\n\r\nexport { Channel };\r\n","import {\r\n\tVector3,\r\n\tPlane,\r\n\tTriangle,\r\n} from 'three';\r\n\r\nimport { Utils } from './Utils';\r\nimport { AStar } from './AStar';\r\nimport { Builder } from './Builder';\r\nimport { Channel } from './Channel';\r\n\r\n/**\r\n * Defines an instance of the pathfinding module, with one or more zones.\r\n */\r\nclass Pathfinding {\r\n\tconstructor () {\r\n\t\tthis.zones = {};\r\n\t}\r\n\r\n\t/**\r\n\t * (Static) Builds a zone/node set from navigation mesh geometry.\r\n\t * @param  {BufferGeometry} geometry\r\n\t * @param  {number} tolerance Vertex welding tolerance.\r\n\t * @return {Zone}\r\n\t */\r\n\tstatic createZone (geometry, tolerance = 1e-4) {\r\n\t\treturn Builder.buildZone(geometry, tolerance);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets data for the given zone.\r\n\t * @param {string} zoneID\r\n\t * @param {Zone} zone\r\n\t */\r\n\tsetZoneData (zoneID, zone) {\r\n\t\tthis.zones[zoneID] = zone;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a random node within a given range of a given position.\r\n\t * @param  {string} zoneID\r\n\t * @param  {number} groupID\r\n\t * @param  {Vector3} nearPosition\r\n\t * @param  {number} nearRange\r\n\t * @return {Node}\r\n\t */\r\n\tgetRandomNode (zoneID, groupID, nearPosition, nearRange) {\r\n\r\n\t\tif (!this.zones[zoneID]) return new Vector3();\r\n\r\n\t\tnearPosition = nearPosition || null;\r\n\t\tnearRange = nearRange || 0;\r\n\r\n\t\tconst candidates = [];\r\n\t\tconst polygons = this.zones[zoneID].groups[groupID];\r\n\r\n\t\tpolygons.forEach((p) => {\r\n\t\t\tif (nearPosition && nearRange) {\r\n\t\t\t\tif (Utils.distanceToSquared(nearPosition, p.centroid) < nearRange * nearRange) {\r\n\t\t\t\t\tcandidates.push(p.centroid);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcandidates.push(p.centroid);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn Utils.sample(candidates) || new Vector3();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the closest node to the target position.\r\n\t * @param  {Vector3} position\r\n\t * @param  {string}  zoneID\r\n\t * @param  {number}  groupID\r\n\t * @param  {boolean} checkPolygon\r\n\t * @return {Node}\r\n\t */\r\n\tgetClosestNode (position, zoneID, groupID, checkPolygon = false) {\r\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\r\n\t\tconst vertices = this.zones[zoneID].vertices;\r\n\t\tlet closestNode = null;\r\n\t\tlet closestDistance = Infinity;\r\n\r\n\t\tnodes.forEach((node) => {\r\n\t\t\tconst distance = Utils.distanceToSquared(node.centroid, position);\r\n\t\t\tif (distance < closestDistance\r\n\t\t\t\t\t&& (!checkPolygon || Utils.isVectorInPolygon(position, node, vertices))) {\r\n\t\t\t\tclosestNode = node;\r\n\t\t\t\tclosestDistance = distance;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn closestNode;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a path between given start and end points. If a complete path\r\n\t * cannot be found, will return the nearest endpoint available.\r\n\t *\r\n\t * @param  {Vector3} startPosition Start position.\r\n\t * @param  {Vector3} targetPosition Destination.\r\n\t * @param  {string} zoneID ID of current zone.\r\n\t * @param  {number} groupID Current group ID.\r\n\t * @return {Array<Vector3>} Array of points defining the path.\r\n\t */\r\n\tfindPath (startPosition, targetPosition, zoneID, groupID) {\r\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\r\n\t\tconst vertices = this.zones[zoneID].vertices;\r\n\r\n\t\t// const closestNode = this.getClosestNode(startPosition, zoneID, groupID, true);\r\n        // breaking fix of bug this issues: https://github.com/donmccurdy/three-pathfinding/issues/79\r\n        const closestNode = this.getClosestNode(startPosition, zoneID, groupID, false);\r\n\t\tconst farthestNode = this.getClosestNode(targetPosition, zoneID, groupID, true);\r\n\r\n\t\t// If we can't find any node, just go straight to the target\r\n\t\tif (!closestNode || !farthestNode) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tconst paths = AStar.search(nodes, closestNode, farthestNode);\r\n\r\n\t\tconst getPortalFromTo = function (a, b) {\r\n\t\t\tfor (var i = 0; i < a.neighbours.length; i++) {\r\n\t\t\t\tif (a.neighbours[i] === b.id) {\r\n\t\t\t\t\treturn a.portals[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// We have the corridor, now pull the rope.\r\n\t\tconst channel = new Channel();\r\n\t\tchannel.push(startPosition);\r\n\t\tfor (let i = 0; i < paths.length; i++) {\r\n\t\t\tconst polygon = paths[i];\r\n\t\t\tconst nextPolygon = paths[i + 1];\r\n\r\n\t\t\tif (nextPolygon) {\r\n\t\t\t\tconst portals = getPortalFromTo(polygon, nextPolygon);\r\n\t\t\t\tchannel.push(\r\n\t\t\t\t\tvertices[portals[0]],\r\n\t\t\t\t\tvertices[portals[1]]\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t\tchannel.push(targetPosition);\r\n\t\tchannel.stringPull();\r\n\r\n\t\t// Return the path, omitting first position (which is already known).\r\n\t\tconst path = channel.path.map((c) => new Vector3(c.x, c.y, c.z));\r\n\t\tpath.shift();\r\n\t\treturn path;\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns closest node group ID for given position.\r\n * @param  {string} zoneID\r\n * @param  {Vector3} position\r\n * @return {number}\r\n */\r\nPathfinding.prototype.getGroup = (function() {\r\n\tconst plane = new Plane();\r\n\treturn function (zoneID, position, checkPolygon = false) {\r\n\t\tif (!this.zones[zoneID]) return null;\r\n\r\n\t\tlet closestNodeGroup = null;\r\n\t\tlet distance = Math.pow(50, 2);\r\n\t\tconst zone = this.zones[zoneID];\r\n\r\n\t\tfor (let i = 0; i < zone.groups.length; i++) {\r\n\t\t\tconst group = zone.groups[i];\r\n\t\t\tfor (const node of group) {\r\n\t\t\t\tif (checkPolygon) {\r\n\t\t\t\t\tplane.setFromCoplanarPoints(\r\n\t\t\t\t\t\tzone.vertices[node.vertexIds[0]],\r\n\t\t\t\t\t\tzone.vertices[node.vertexIds[1]],\r\n\t\t\t\t\t\tzone.vertices[node.vertexIds[2]]\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif (Math.abs(plane.distanceToPoint(position)) < 0.01) {\r\n\t\t\t\t\t\tconst poly = [\r\n\t\t\t\t\t\t\tzone.vertices[node.vertexIds[0]],\r\n\t\t\t\t\t\t\tzone.vertices[node.vertexIds[1]],\r\n\t\t\t\t\t\t\tzone.vertices[node.vertexIds[2]]\r\n\t\t\t\t\t\t];\r\n\t\t\t\t\t\tif(Utils.isPointInPoly(poly, position)) {\r\n\t\t\t\t\t\t\treturn i;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tconst measuredDistance = Utils.distanceToSquared(node.centroid, position);\r\n\t\t\t\tif (measuredDistance < distance) {\r\n\t\t\t\t\tclosestNodeGroup = i;\r\n\t\t\t\t\tdistance = measuredDistance;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn closestNodeGroup;\r\n\t};\r\n}());\r\n\r\n/**\r\n * Clamps a step along the navmesh, given start and desired endpoint. May be\r\n * used to constrain first-person / WASD controls.\r\n *\r\n * @param  {Vector3} start\r\n * @param  {Vector3} end Desired endpoint.\r\n * @param  {Node} node\r\n * @param  {string} zoneID\r\n * @param  {number} groupID\r\n * @param  {Vector3} endTarget Updated endpoint.\r\n * @return {Node} Updated node.\r\n */\r\nPathfinding.prototype.clampStep = (function () {\r\n\tconst point = new Vector3();\r\n\tconst plane = new Plane();\r\n\tconst triangle = new Triangle();\r\n\r\n\tconst endPoint = new Vector3();\r\n\r\n\tlet closestNode;\r\n\tlet closestPoint = new Vector3();\r\n\tlet closestDistance;\r\n\r\n\treturn function (startRef, endRef, node, zoneID, groupID, endTarget) {\r\n\t\tconst vertices = this.zones[zoneID].vertices;\r\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\r\n\r\n\t\tconst nodeQueue = [node];\r\n\t\tconst nodeDepth = {};\r\n\t\tnodeDepth[node.id] = 0;\r\n\r\n\t\tclosestNode = undefined;\r\n\t\tclosestPoint.set(0, 0, 0);\r\n\t\tclosestDistance = Infinity;\r\n\r\n\t\t// Project the step along the current node.\r\n\t\tplane.setFromCoplanarPoints(\r\n\t\t\tvertices[node.vertexIds[0]],\r\n\t\t\tvertices[node.vertexIds[1]],\r\n\t\t\tvertices[node.vertexIds[2]]\r\n\t\t);\r\n\t\tplane.projectPoint(endRef, point);\r\n\t\tendPoint.copy(point);\r\n\r\n\t\tfor (let currentNode = nodeQueue.pop(); currentNode; currentNode = nodeQueue.pop()) {\r\n\r\n\t\t\ttriangle.set(\r\n\t\t\t\tvertices[currentNode.vertexIds[0]],\r\n\t\t\t\tvertices[currentNode.vertexIds[1]],\r\n\t\t\t\tvertices[currentNode.vertexIds[2]]\r\n\t\t\t);\r\n\r\n\t\t\ttriangle.closestPointToPoint(endPoint, point);\r\n\r\n\t\t\tif (point.distanceToSquared(endPoint) < closestDistance) {\r\n\t\t\t\tclosestNode = currentNode;\r\n\t\t\t\tclosestPoint.copy(point);\r\n\t\t\t\tclosestDistance = point.distanceToSquared(endPoint);\r\n\t\t\t}\r\n\r\n\t\t\tconst depth = nodeDepth[currentNode.id];\r\n\t\t\tif (depth > 2) continue;\r\n\r\n\t\t\tfor (let i = 0; i < currentNode.neighbours.length; i++) {\r\n\t\t\t\tconst neighbour = nodes[currentNode.neighbours[i]];\r\n\t\t\t\tif (neighbour.id in nodeDepth) continue;\r\n\r\n\t\t\t\tnodeQueue.push(neighbour);\r\n\t\t\t\tnodeDepth[neighbour.id] = depth + 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tendTarget.copy(closestPoint);\r\n\t\treturn closestNode;\r\n\t};\r\n}());\r\n\r\n/**\r\n * Defines a zone of interconnected groups on a navigation mesh.\r\n *\r\n * @type {Object}\r\n * @property {Array<Group>} groups\r\n * @property {Array<Vector3>} vertices\r\n */\r\nconst Zone = {}; // jshint ignore:line\r\n\r\n/**\r\n * Defines a group within a navigation mesh.\r\n *\r\n * @type {Object}\r\n */\r\nconst Group = {}; // jshint ignore:line\r\n\r\n/**\r\n * Defines a node (or polygon) within a group.\r\n *\r\n * @type {Object}\r\n * @property {number} id\r\n * @property {Array<number>} neighbours IDs of neighboring nodes.\r\n * @property {Array<number>} vertexIds\r\n * @property {Vector3} centroid\r\n * @property {Array<Array<number>>} portals Array of portals, each defined by two vertex IDs.\r\n * @property {boolean} closed\r\n * @property {number} cost\r\n */\r\nconst Node = {}; // jshint ignore:line\r\n\r\nexport { Pathfinding };\r\n","import { Vector3 } from 'three';\r\n\r\nimport { Utils } from './Utils';\r\n\r\nclass Builder {\r\n  /**\r\n   * Constructs groups from the given navigation mesh.\r\n   * @param  {BufferGeometry} geometry\r\n   * @param  {number} tolerance\r\n   * @return {Zone}\r\n   */\r\n  static buildZone (geometry, tolerance) {\r\n\r\n    const navMesh = this._buildNavigationMesh(geometry, tolerance);\r\n\r\n    const zone = {};\r\n\r\n    navMesh.vertices.forEach((v) => {\r\n      v.x = Utils.roundNumber(v.x, 2);\r\n      v.y = Utils.roundNumber(v.y, 2);\r\n      v.z = Utils.roundNumber(v.z, 2);\r\n    });\r\n\r\n    zone.vertices = navMesh.vertices;\r\n\r\n    const groups = this._buildPolygonGroups(navMesh);\r\n\r\n    // TODO: This block represents a large portion of navigation mesh construction time\r\n    // and could probably be optimized. For example, construct portals while\r\n    // determining the neighbor graph.\r\n    zone.groups = new Array(groups.length);\r\n    groups.forEach((group, groupIndex) => {\r\n\r\n      const indexByPolygon = new Map(); // { polygon: index in group }\r\n      group.forEach((poly, polyIndex) => { indexByPolygon.set(poly, polyIndex); });\r\n\r\n      const newGroup = new Array(group.length);\r\n      group.forEach((poly, polyIndex) => {\r\n\r\n        const neighbourIndices = [];\r\n        poly.neighbours.forEach((n) => neighbourIndices.push(indexByPolygon.get(n)));\r\n\r\n        // Build a portal list to each neighbour\r\n        const portals = [];\r\n        poly.neighbours.forEach((n) => portals.push(this._getSharedVerticesInOrder(poly, n)));\r\n\r\n        const centroid = new Vector3( 0, 0, 0 );\r\n        centroid.add( zone.vertices[ poly.vertexIds[0] ] );\r\n        centroid.add( zone.vertices[ poly.vertexIds[1] ] );\r\n        centroid.add( zone.vertices[ poly.vertexIds[2] ] );\r\n        centroid.divideScalar( 3 );\r\n        centroid.x = Utils.roundNumber(centroid.x, 2);\r\n        centroid.y = Utils.roundNumber(centroid.y, 2);\r\n        centroid.z = Utils.roundNumber(centroid.z, 2);\r\n\r\n        newGroup[polyIndex] = {\r\n          id: polyIndex,\r\n          neighbours: neighbourIndices,\r\n          vertexIds: poly.vertexIds,\r\n          centroid: centroid,\r\n          portals: portals\r\n        };\r\n      });\r\n\r\n      zone.groups[groupIndex] = newGroup;\r\n    });\r\n\r\n    return zone;\r\n  }\r\n\r\n  /**\r\n   * Constructs a navigation mesh from the given geometry.\r\n   * @param {BufferGeometry} geometry\r\n   * @return {Object}\r\n   */\r\n  static _buildNavigationMesh (geometry, tolerance) {\r\n    geometry = Utils.mergeVertices(geometry, tolerance);\r\n    return this._buildPolygonsFromGeometry(geometry);\r\n  }\r\n\r\n  /**\r\n   * Spreads the group ID of the given polygon to all connected polygons\r\n   * @param {Object} seed\r\n   */\r\n  static _spreadGroupId (seed) {\r\n    let nextBatch = new Set([seed]);\r\n\r\n    while(nextBatch.size > 0) {\r\n      const batch = nextBatch;\r\n      nextBatch = new Set();\r\n\r\n      batch.forEach((polygon) => {\r\n        polygon.group = seed.group;\r\n        polygon.neighbours.forEach((neighbour) => {\r\n          if(neighbour.group === undefined) {\r\n            nextBatch.add(neighbour);\r\n          }\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  static _buildPolygonGroups (navigationMesh) {\r\n\r\n    const polygons = navigationMesh.polygons;\r\n\r\n    const polygonGroups = [];\r\n\r\n    polygons.forEach((polygon) => {\r\n      if (polygon.group !== undefined) {\r\n        // this polygon is already part of a group\r\n        polygonGroups[polygon.group].push(polygon);\r\n      } else {\r\n        // we need to make a new group and spread its ID to neighbors\r\n        polygon.group = polygonGroups.length;\r\n        this._spreadGroupId(polygon);\r\n        polygonGroups.push([polygon]);\r\n      }\r\n    });\r\n\r\n    return polygonGroups;\r\n  }\r\n\r\n  static _buildPolygonNeighbours (polygon, vertexPolygonMap) {\r\n    const neighbours = new Set();\r\n\r\n    const groupA = vertexPolygonMap[polygon.vertexIds[0]];\r\n    const groupB = vertexPolygonMap[polygon.vertexIds[1]];\r\n    const groupC = vertexPolygonMap[polygon.vertexIds[2]];\r\n\r\n    // It's only necessary to iterate groups A and B. Polygons contained only\r\n    // in group C cannot share a >1 vertex with this polygon.\r\n    // IMPORTANT: Bublé cannot compile for-of loops.\r\n    groupA.forEach((candidate) => {\r\n      if (candidate === polygon) return;\r\n      if (groupB.includes(candidate) || groupC.includes(candidate)) {\r\n        neighbours.add(candidate);\r\n      }\r\n    });\r\n    groupB.forEach((candidate) => {\r\n      if (candidate === polygon) return;\r\n      if (groupC.includes(candidate)) {\r\n        neighbours.add(candidate);\r\n      }\r\n    });\r\n\r\n    return neighbours;\r\n  }\r\n\r\n  static _buildPolygonsFromGeometry (geometry) {\r\n\r\n    const polygons = [];\r\n    const vertices = [];\r\n\r\n    const position = geometry.attributes.position;\r\n    const index = geometry.index;\r\n\r\n    // Constructing the neighbor graph brute force is O(n²). To avoid that,\r\n    // create a map from vertices to the polygons that contain them, and use it\r\n    // while connecting polygons. This reduces complexity to O(n*m), where 'm'\r\n    // is related to connectivity of the mesh.\r\n\r\n    /** Array of polygon objects by vertex index. */\r\n    const vertexPolygonMap = [];\r\n\r\n    for (let i = 0; i < position.count; i++) {\r\n      vertices.push(new Vector3().fromBufferAttribute(position, i));\r\n      vertexPolygonMap[i] = [];\r\n    }\r\n\r\n    // Convert the faces into a custom format that supports more than 3 vertices\r\n    for (let i = 0; i < geometry.index.count; i += 3) {\r\n      const a = index.getX(i);\r\n      const b = index.getX(i + 1);\r\n      const c = index.getX(i + 2);\r\n      const poly = {vertexIds: [a, b, c], neighbours: null};\r\n      polygons.push(poly);\r\n      vertexPolygonMap[a].push(poly);\r\n      vertexPolygonMap[b].push(poly);\r\n      vertexPolygonMap[c].push(poly);\r\n    }\r\n\r\n    // Build a list of adjacent polygons\r\n    polygons.forEach((polygon) => {\r\n      polygon.neighbours = this._buildPolygonNeighbours(polygon, vertexPolygonMap);\r\n    });\r\n\r\n    return {\r\n      polygons: polygons,\r\n      vertices: vertices\r\n    };\r\n  }\r\n\r\n  static _getSharedVerticesInOrder (a, b) {\r\n\r\n    const aList = a.vertexIds;\r\n    const a0 = aList[0], a1 = aList[1], a2 = aList[2];\r\n\r\n    const bList = b.vertexIds;\r\n    const shared0 = bList.includes(a0);\r\n    const shared1 = bList.includes(a1);\r\n    const shared2 = bList.includes(a2);\r\n\r\n    // it seems that we shouldn't have an a and b with <2 shared vertices here unless there's a bug\r\n    // in the neighbor identification code, or perhaps a malformed input geometry; 3 shared vertices\r\n    // is a kind of embarrassing but possible geometry we should handle\r\n    if (shared0 && shared1 && shared2) {\r\n      return Array.from(aList);\r\n    } else if (shared0 && shared1) {\r\n      return [a0, a1];\r\n    } else if (shared1 && shared2) {\r\n      return [a1, a2];\r\n    } else if (shared0 && shared2) {\r\n      return [a2, a0]; // this ordering will affect the string pull algorithm later, not clear if significant\r\n    } else {\r\n      console.warn(\"Error processing navigation mesh neighbors; neighbors with <2 shared vertices found.\");\r\n      return [];\r\n    }\r\n  }\r\n}\r\n\r\nexport { Builder };\r\n","import { BinaryHeap } from './BinaryHeap';\r\nimport { Utils } from './Utils.js';\r\n\r\nclass AStar {\r\n  static init (graph) {\r\n    for (let x = 0; x < graph.length; x++) {\r\n      //for(var x in graph) {\r\n      const node = graph[x];\r\n      node.f = 0;\r\n      node.g = 0;\r\n      node.h = 0;\r\n      node.cost = 1.0;\r\n      node.visited = false;\r\n      node.closed = false;\r\n      node.parent = null;\r\n    }\r\n  }\r\n\r\n  static cleanUp (graph) {\r\n    for (let x = 0; x < graph.length; x++) {\r\n      const node = graph[x];\r\n      delete node.f;\r\n      delete node.g;\r\n      delete node.h;\r\n      delete node.cost;\r\n      delete node.visited;\r\n      delete node.closed;\r\n      delete node.parent;\r\n    }\r\n  }\r\n\r\n  static heap () {\r\n    return new BinaryHeap(function (node) {\r\n      return node.f;\r\n    });\r\n  }\r\n\r\n  static search (graph, start, end) {\r\n    this.init(graph);\r\n    //heuristic = heuristic || astar.manhattan;\r\n\r\n\r\n    const openHeap = this.heap();\r\n\r\n    openHeap.push(start);\r\n\r\n    while (openHeap.size() > 0) {\r\n\r\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\r\n      const currentNode = openHeap.pop();\r\n\r\n      // End case -- result has been found, return the traced path.\r\n      if (currentNode === end) {\r\n        let curr = currentNode;\r\n        const ret = [];\r\n        while (curr.parent) {\r\n          ret.push(curr);\r\n          curr = curr.parent;\r\n        }\r\n        this.cleanUp(ret);\r\n        return ret.reverse();\r\n      }\r\n\r\n      // Normal case -- move currentNode from open to closed, process each of its neighbours.\r\n      currentNode.closed = true;\r\n\r\n      // Find all neighbours for the current node. Optionally find diagonal neighbours as well (false by default).\r\n      const neighbours = this.neighbours(graph, currentNode);\r\n\r\n      for (let i = 0, il = neighbours.length; i < il; i++) {\r\n        const neighbour = neighbours[i];\r\n\r\n        if (neighbour.closed) {\r\n          // Not a valid node to process, skip to next neighbour.\r\n          continue;\r\n        }\r\n\r\n        // The g score is the shortest distance from start to current node.\r\n        // We need to check if the path we have arrived at this neighbour is the shortest one we have seen yet.\r\n        const gScore = currentNode.g + neighbour.cost;\r\n        const beenVisited = neighbour.visited;\r\n\r\n        if (!beenVisited || gScore < neighbour.g) {\r\n\r\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\r\n          neighbour.visited = true;\r\n          neighbour.parent = currentNode;\r\n          if (!neighbour.centroid || !end.centroid) throw new Error('Unexpected state');\r\n          neighbour.h = neighbour.h || this.heuristic(neighbour.centroid, end.centroid);\r\n          neighbour.g = gScore;\r\n          neighbour.f = neighbour.g + neighbour.h;\r\n\r\n          if (!beenVisited) {\r\n            // Pushing to heap will put it in proper place based on the 'f' value.\r\n            openHeap.push(neighbour);\r\n          } else {\r\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\r\n            openHeap.rescoreElement(neighbour);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // No result was found - empty array signifies failure to find path.\r\n    return [];\r\n  }\r\n\r\n  static heuristic (pos1, pos2) {\r\n    return Utils.distanceToSquared(pos1, pos2);\r\n  }\r\n\r\n  static neighbours (graph, node) {\r\n    const ret = [];\r\n\r\n    for (let e = 0; e < node.neighbours.length; e++) {\r\n      ret.push(graph[node.neighbours[e]]);\r\n    }\r\n\r\n    return ret;\r\n  }\r\n}\r\n\r\nexport { AStar };\r\n","import {\r\n  BoxBufferGeometry,\r\n  BufferAttribute,\r\n  BufferGeometry,\r\n  Color,\r\n  Line,\r\n  LineBasicMaterial,\r\n  Mesh,\r\n  MeshBasicMaterial,\r\n  Object3D,\r\n  SphereBufferGeometry,\r\n  Vector3,\r\n} from 'three';\r\n\r\nconst colors = {\r\n  PLAYER: new Color( 0xee836f ).convertGammaToLinear( 2.2 ).getHex(),\r\n  TARGET: new Color( 0xdccb18 ).convertGammaToLinear( 2.2 ).getHex(),\r\n  PATH: new Color( 0x00a3af ).convertGammaToLinear( 2.2 ).getHex(),\r\n  WAYPOINT: new Color( 0x00a3af ).convertGammaToLinear( 2.2 ).getHex(),\r\n  CLAMPED_STEP: new Color( 0xdcd3b2 ).convertGammaToLinear( 2.2 ).getHex(),\r\n  CLOSEST_NODE: new Color( 0x43676b ).convertGammaToLinear( 2.2 ).getHex(),\r\n};\r\n\r\nconst OFFSET = 0.2;\r\n\r\n/**\r\n * Helper for debugging pathfinding behavior.\r\n */\r\nclass PathfindingHelper extends Object3D {\r\n  constructor () {\r\n    super();\r\n\r\n    this._playerMarker = new Mesh(\r\n      new SphereBufferGeometry( 0.25, 32, 32 ),\r\n      new MeshBasicMaterial( { color: colors.PLAYER } )\r\n    );\r\n\r\n    this._targetMarker = new Mesh(\r\n      new BoxBufferGeometry( 0.3, 0.3, 0.3 ),\r\n      new MeshBasicMaterial( { color: colors.TARGET } )\r\n    );\r\n\r\n\r\n    this._nodeMarker = new Mesh(\r\n      new BoxBufferGeometry( 0.1, 0.8, 0.1 ),\r\n      new MeshBasicMaterial( { color: colors.CLOSEST_NODE } )\r\n    );\r\n\r\n\r\n    this._stepMarker = new Mesh(\r\n      new BoxBufferGeometry( 0.1, 1, 0.1 ),\r\n      new MeshBasicMaterial( { color: colors.CLAMPED_STEP } )\r\n    );\r\n\r\n    this._pathMarker = new Object3D();\r\n\r\n    this._pathLineMaterial = new LineBasicMaterial( { color: colors.PATH, linewidth: 2 } ) ;\r\n    this._pathPointMaterial = new MeshBasicMaterial( { color: colors.WAYPOINT } );\r\n    this._pathPointGeometry = new SphereBufferGeometry( 0.08 );\r\n\r\n    this._markers = [\r\n      this._playerMarker,\r\n      this._targetMarker,\r\n      this._nodeMarker,\r\n      this._stepMarker,\r\n      this._pathMarker,\r\n    ];\r\n\r\n    this._markers.forEach( ( marker ) => {\r\n\r\n      marker.visible = false;\r\n\r\n      this.add( marker );\r\n\r\n    } );\r\n\r\n  }\r\n\r\n  /**\r\n   * @param {Array<Vector3>} path\r\n   * @return {this}\r\n   */\r\n  setPath ( path ) {\r\n\r\n    while ( this._pathMarker.children.length ) {\r\n\r\n      this._pathMarker.children[ 0 ].visible = false;\r\n      this._pathMarker.remove( this._pathMarker.children[ 0 ] );\r\n\r\n    }\r\n\r\n    path = [ this._playerMarker.position ].concat( path );\r\n\r\n    // Draw debug lines\r\n    const geometry = new BufferGeometry();\r\n    geometry.setAttribute('position', new BufferAttribute(new Float32Array(path.length * 3), 3));\r\n    for (let i = 0; i < path.length; i++) {\r\n      geometry.attributes.position.setXYZ(i, path[ i ].x, path[ i ].y + OFFSET, path[ i ].z);\r\n    }\r\n    this._pathMarker.add( new Line( geometry, this._pathLineMaterial ) );\r\n\r\n    for ( let i = 0; i < path.length - 1; i++ ) {\r\n\r\n      const node = new Mesh( this._pathPointGeometry, this._pathPointMaterial );\r\n      node.position.copy( path[ i ] );\r\n      node.position.y += OFFSET;\r\n      this._pathMarker.add( node );\r\n\r\n    }\r\n\r\n    this._pathMarker.visible = true;\r\n\r\n    return this;\r\n\r\n  }\r\n\r\n  /**\r\n   * @param {Vector3} position\r\n   * @return {this}\r\n   */\r\n  setPlayerPosition( position ) {\r\n\r\n    this._playerMarker.position.copy( position );\r\n    this._playerMarker.visible = true;\r\n    return this;\r\n\r\n  }\r\n\r\n  /**\r\n   * @param {Vector3} position\r\n   * @return {this}\r\n   */\r\n  setTargetPosition( position ) {\r\n\r\n    this._targetMarker.position.copy( position );\r\n    this._targetMarker.visible = true;\r\n    return this;\r\n\r\n  }\r\n\r\n  /**\r\n   * @param {Vector3} position\r\n   * @return {this}\r\n   */\r\n  setNodePosition( position ) {\r\n\r\n    this._nodeMarker.position.copy( position );\r\n    this._nodeMarker.visible = true;\r\n    return this;\r\n\r\n  }\r\n\r\n  /**\r\n   * @param {Vector3} position\r\n   * @return {this}\r\n   */\r\n  setStepPosition( position ) {\r\n\r\n    this._stepMarker.position.copy( position );\r\n    this._stepMarker.visible = true;\r\n    return this;\r\n\r\n  }\r\n\r\n  /**\r\n   * Hides all markers.\r\n   * @return {this}\r\n   */\r\n  reset () {\r\n\r\n    while ( this._pathMarker.children.length ) {\r\n\r\n      this._pathMarker.children[ 0 ].visible = false;\r\n      this._pathMarker.remove( this._pathMarker.children[ 0 ] );\r\n\r\n    }\r\n\r\n    this._markers.forEach( ( marker ) => {\r\n\r\n      marker.visible = false;\r\n\r\n    } );\r\n\r\n    return this;\r\n\r\n  }\r\n\r\n}\r\n\r\nexport { PathfindingHelper };\r\n"],"names":["Utils","static","value","decimals","factor","Math","pow","round","list","floor","random","length","a","b","dx","x","dy","y","dz","z","poly","pt","c","i","l","j","vector","polygon","vertices","lowestPoint","highestPoint","polygonVertices","vertexIds","forEach","vId","min","max","push","this","isPointInPoly","distanceToSquared","geometry","tolerance","Number","EPSILON","hashToIndex","indices","getIndex","positions","getAttribute","vertexCount","count","nextIndex","newIndices","newPositions","decimalShift","log10","shiftMultiplier","index","getX","hash","getY","getZ","positionAttribute","BufferAttribute","Float32Array","itemSize","normalized","result","BufferGeometry","setAttribute","setIndex","BinaryHeap","constructor","scoreFunction","content","element","sinkDown","pop","end","bubbleUp","remove","node","indexOf","size","rescoreElement","n","parentN","parent","elemScore","child2N","child1N","child1Score","swap","Channel","portals","p1","p2","undefined","left","right","stringPull","pts","portalApex","portalLeft","portalRight","apexIndex","leftIndex","rightIndex","triarea2","vequal","path","Pathfinding","zones","navMesh","_buildNavigationMesh","zone","v","roundNumber","groups","_buildPolygonGroups","Array","group","groupIndex","indexByPolygon","Map","polyIndex","set","newGroup","neighbourIndices","neighbours","get","_getSharedVerticesInOrder","centroid","Vector3","add","divideScalar","id","mergeVertices","_buildPolygonsFromGeometry","seed","nextBatch","Set","batch","neighbour","navigationMesh","polygonGroups","polygons","_spreadGroupId","vertexPolygonMap","groupB","groupC","candidate","includes","position","attributes","fromBufferAttribute","_buildPolygonNeighbours","aList","a0","a1","a2","bList","shared0","shared1","shared2","from","console","warn","buildZone","setZoneData","zoneID","getRandomNode","groupID","nearPosition","nearRange","candidates","p","sample","getClosestNode","checkPolygon","closestNode","closestDistance","Infinity","distance","isVectorInPolygon","findPath","startPosition","targetPosition","nodes","farthestNode","paths","graph","f","g","h","cost","visited","closed","start","init","openHeap","heap","currentNode","curr","ret","cleanUp","reverse","il","gScore","beenVisited","Error","heuristic","pos1","pos2","e","search","getPortalFromTo","channel","nextPolygon","map","shift","prototype","getGroup","plane","Plane","closestNodeGroup","setFromCoplanarPoints","abs","distanceToPoint","measuredDistance","clampStep","point","triangle","Triangle","endPoint","closestPoint","startRef","endRef","endTarget","nodeQueue","nodeDepth","projectPoint","copy","closestPointToPoint","depth","colors","PLAYER","Color","convertGammaToLinear","getHex","TARGET","PATH","WAYPOINT","CLAMPED_STEP","CLOSEST_NODE","PathfindingHelper","Object3D","super","_playerMarker","Mesh","SphereBufferGeometry","MeshBasicMaterial","color","_targetMarker","BoxBufferGeometry","_nodeMarker","_stepMarker","_pathMarker","_pathLineMaterial","LineBasicMaterial","linewidth","_pathPointMaterial","_pathPointGeometry","_markers","marker","visible","setPath","children","concat","setXYZ","Line","setPlayerPosition","setTargetPosition","setNodePosition","setStepPosition","reset"],"mappings":"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"}